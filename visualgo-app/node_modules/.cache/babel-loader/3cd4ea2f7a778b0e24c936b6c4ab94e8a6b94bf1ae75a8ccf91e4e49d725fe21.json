{"ast":null,"code":"import bin_graph from \"./binTree\";\nimport grid_graph from \"./grid\";\nfunction generateGraph(nodes, grid, scheme) {\n  // let data = {\n  //   nodes: [\n  //     { id: 1, label: \"Node 1\", title: \"node 1 tootip text\" },\n  //     { id: 2, label: \"Node 2\", title: \"node 2 tootip text\" },\n  //     { id: 3, label: \"Node 3\", title: \"node 3 tootip text\" },\n  //     { id: 4, label: \"Node 4\", title: \"node 4 tootip text\" },\n  //     { id: 5, label: \"Node 5\", title: \"node 5 tootip text\" }\n  //   ],\n  //   edges: [\n  //     { from: 1, to: 2 },\n  //     { from: 1, to: 3 },\n  //     { from: 2, to: 4 },\n  //     { from: 4, to: 2 },\n  //     { from: 2, to: 1 },\n  //     { from: 2, to: 5 }\n  //   ]\n  // };\n  let data = null;\n  if (grid == 'SQR') {\n    data = grid_graph(nodes, 'square');\n    // return data;\n  } else if (grid == 'BIN') {\n    data = bin_graph(nodes);\n    // return data;\n  } else {\n    alert('not implemented error!');\n    return {\n      nodes: [],\n      edges: []\n    };\n  }\n  if (scheme == 'None') {\n    return data;\n  } else if (scheme == 'N5') {\n    let n = data.nodes.length;\n    let rs = n / 20;\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.nodes.length);\n      const el = data.nodes.splice(random, 1)[0];\n      data.edges.forEach(element => {\n        if (element.from == el || element.to == el) {\n          const index = data.egdes.indexOf(element);\n          data.edges.splice(index, 1);\n        }\n      });\n      console.log(el);\n    }\n  } else if (scheme == 'E5') {\n    let n = data.edges.length;\n    let rs = n / 20;\n\n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.edges.length);\n      const el = data.edges.splice(random, 1)[0];\n      alert(el.from + \" \" + el.to);\n    }\n  } else if (scheme == 'N10') {\n    let n = data.nodes.length;\n    let rs = n / 10;\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.nodes.length);\n      const el = data.nodes.splice(random, 1)[0];\n      data.edges.forEach(element => {\n        if (element.from == el || element.to == el) {\n          const index = data.egdes.indexOf(element);\n          data.edges.splice(index, 1);\n        }\n      });\n      console.log(el);\n    }\n  } else if (scheme == 'E10') {\n    let n = data.edges.length;\n    let rs = n / 10;\n\n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.edges.length);\n      const el = data.edges.splice(random, 1)[0];\n      alert(el.from + \" \" + el.to);\n    }\n  } else if (scheme == 'N20') {\n    let n = data.nodes.length;\n    let rs = n / 5;\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.nodes.length);\n      const el = data.nodes.splice(random, 1)[0];\n      data.edges.forEach(element => {\n        if (element.from == el || element.to == el) {\n          const index = data.egdes.indexOf(element);\n          data.edges.splice(index, 1);\n        }\n      });\n      console.log(el);\n    }\n  } else if (scheme == 'E20') {\n    let n = data.edges.length;\n    let rs = n / 5;\n\n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n    while (rs > 0) {\n      rs -= 1;\n      const random = Math.floor(Math.random() * data.edges.length);\n      const el = data.edges.splice(random, 1)[0];\n      alert(el.from + \" \" + el.to);\n    }\n  } else {\n    alert('not implemented error!');\n    return data;\n  }\n  return data;\n}\nexport default generateGraph;","map":{"version":3,"names":["bin_graph","grid_graph","generateGraph","nodes","grid","scheme","data","alert","edges","n","length","rs","random","Math","floor","el","splice","forEach","element","from","to","index","egdes","indexOf","console","log"],"sources":["/home/vedant/visualgo/visualgo-app/src/algorithms/graph_gen/factory.js"],"sourcesContent":["import bin_graph from \"./binTree\"\nimport grid_graph from \"./grid\"\n\nfunction generateGraph (nodes, grid, scheme) {\n    // let data = {\n    //   nodes: [\n    //     { id: 1, label: \"Node 1\", title: \"node 1 tootip text\" },\n    //     { id: 2, label: \"Node 2\", title: \"node 2 tootip text\" },\n    //     { id: 3, label: \"Node 3\", title: \"node 3 tootip text\" },\n    //     { id: 4, label: \"Node 4\", title: \"node 4 tootip text\" },\n    //     { id: 5, label: \"Node 5\", title: \"node 5 tootip text\" }\n    //   ],\n    //   edges: [\n    //     { from: 1, to: 2 },\n    //     { from: 1, to: 3 },\n    //     { from: 2, to: 4 },\n    //     { from: 4, to: 2 },\n    //     { from: 2, to: 1 },\n    //     { from: 2, to: 5 }\n    //   ]\n    // };\n    let data = null\n    if(grid == 'SQR') {\n      data = grid_graph(nodes, 'square')\n      // return data;\n    } else if(grid == 'BIN') {\n      data = bin_graph(nodes)\n      // return data;\n    } else {\n      alert('not implemented error!')\n      return {nodes : [], edges : []}\n    }\n  \n  \n    if(scheme == 'None') {\n      return data;\n    }\n    else if(scheme == 'N5') {\n      let n = data.nodes.length\n      let rs = n / 20\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.nodes.length);\n        const el = data.nodes.splice(random, 1)[0];\n        data.edges.forEach(element => {\n          if(element.from == el || element.to == el) {\n            const index = data.egdes.indexOf(element)\n            data.edges.splice(index, 1)\n          }\n        });\n        console.log(el);\n      }\n    } else if(scheme == 'E5') {\n      let n = data.edges.length\n      let rs = n / 20\n  \n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.edges.length);\n        const el = data.edges.splice(random, 1)[0];\n        alert(el.from + \" \" + el.to)\n      }\n    }\n    else if(scheme == 'N10') {\n      let n = data.nodes.length\n      let rs = n / 10\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.nodes.length);\n        const el = data.nodes.splice(random, 1)[0];\n        data.edges.forEach(element => {\n          if(element.from == el || element.to == el) {\n            const index = data.egdes.indexOf(element)\n            data.edges.splice(index, 1)\n          }\n        });\n        console.log(el);\n      }\n    } else if(scheme == 'E10') {\n      let n = data.edges.length\n      let rs = n / 10\n  \n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.edges.length);\n        const el = data.edges.splice(random, 1)[0];\n        alert(el.from + \" \" + el.to)\n      }\n    }\n    else if(scheme == 'N20') {\n      let n = data.nodes.length\n      let rs = n / 5\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.nodes.length);\n        const el = data.nodes.splice(random, 1)[0];\n        data.edges.forEach(element => {\n          if(element.from == el || element.to == el) {\n            const index = data.egdes.indexOf(element)\n            data.edges.splice(index, 1)\n          }\n        });\n        console.log(el);\n      }\n    } else if(scheme == 'E20') {\n      let n = data.edges.length\n      let rs = n / 5\n  \n    // alert(data.nodes.length + \" \" + n + \" \" + rs)\n      while(rs > 0) {\n        rs -= 1\n        const random = Math.floor(Math.random() * data.edges.length);\n        const el = data.edges.splice(random, 1)[0];\n        alert(el.from + \" \" + el.to)\n      }\n    }\n    else {\n      alert('not implemented error!')\n      return data;\n    }\n    \n    return data\n  }\n\nexport default generateGraph;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}